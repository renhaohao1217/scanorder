# 小程序功能描述

## 首页

### · 登录

> 用户输入**用户名**或者**手机号**和**密码**，访问数据库`so_shop`进行匹配，如果返回数据，则验证通过，将`_id`通过`wx.setStorage()`缓存到本地作为登录状态，在退出登录的时候将本地缓存移除。

### · 注册

> 用户输入**用户名**、**手机号**、**店名**、**地址**、**登录密码**等信息进行注册，首先通过正则表达式对用户输入的信息进行格式验证。

1. 用户名:`/^[a-zA-Z][a-zA-Z0-9_-]{5,19}$/`
2. 手机号:`/^1[3456789]\d{9}$/`
3. 密码:`/^[a-zA-Z0-9_-]{6,20}$/`

### · 扫码

## 我的

### · 用户信息

1. 修改用户信息的时候，在输入框失去焦点的时候通过`event.detail.value`获取输入框的值，然后对值进行格式的校验，比`bindinput`事件触发的次数少。
2. 通过`wx.getLocation API `获取用户的地理位置，返回值是经度和纬度，然后通过第三方的工具进行经纬度逆解析得到用户的位置信息 。
3. 通过hash值来记录哪些用户信息进行了修改，然后在保存修改的时候，只更新这些修改了的数据，减少了数据库的操作。

### · 报表

> 首先通过`picker`组件设置日期选择器，查看对应日期的订单信息，把`shop_id`、`time`作为查询条件查询`so_order`数据库，返回的数据如下，对数据进行处理之后，通过canvas将数据以柱状图的形式展示出来。

```js
// res.data
{
    "_id": // 订单唯一标识符,
    "_openid": // 提交订单的用户,
    "classify": // 分类信息,
   	"state": // 订单的状态,
    "time": // 订单创建的时间,
    "shop_id": // 商家的_id,
    "goods": [ // 订单包含的商品
     	{
            "_id": // ,
            "_openid": //,
            "amount": // 商品的数量,
            "goodsList": [ // 商品的详细信息,
            	{
            		"_id": // 商品的_id,
            		"_openid": // 上传商品的商家的_openid,
            		"classify_id": // 商品的分类,
            		"cook": // 商品所属后厨,
            		"description": // 商品的描述,
            		"image": // 商品的封面图片,
            		"images": // 商品的轮播图,
            		"price": // 商品的价格,
            		"sale": // 商品是否售馨,
            		"shop_id": // 商家的_id,
            		"time": // 商品上传的时间,
            		"title": // 商品的名称,
        		}
            ]
            "goods_id": // 商品的_id
        }   
    ]
}
```

### · 修改密码

> 首先验证数据格式，然后访问集合`so_shop`进行数据验证，如果验证通过则更新密码。

### · 退出登录

> 通过`wx.removeStorage`删除`_id`标识，退出到登录页面。
>

## 点餐

> 点餐界面有 桌位号点餐`table` 和 流水号点餐`serial` 两个选项，通过路由传参的方法传递给 `business`页面

1. 商家通过 `wx.getStorageSync('_id')`获取`_id`，然后获得商品分类信息，根据商品分类信息获得对应的商品信息
2. 商品信息通过 商品信息集合(so_goods)和购物车集合(so_cart) 联表查询获得每个商品的信息和是否加入购物车的情况
3. 商品列表和购物车信息的同步是通过组件间通信实现的，父组件通过自定义属性的方式将值传给子组件，子组件通过`this.triggerEvent`触发自定义事件的方式将值传给父组件
4. 用户添加购物车和数量的修改事件进行了防抖处理，避免用户频繁点击，然后频繁操作数据库，在用户停止点击300ms之后在将购物车信息更新到数据库中

## 订单

> 根据日期选择器选择对应时间的订单，访问数据库`so_order`，把`shop_id`和`time`作为筛选条件，然后将返回的数据数组通过`wx:for`传入`indent-list`组件，将订单信息渲染成列表。
>
> 使用过滤器filter.wxs将时间戳转换成日期格式。

## 任务

> 通过联表查询`so_order`和`so_task`的数据结合在一起，对每个任务中的商品绑定点击事件，当点击的时候展示已完成，当一个任务中的所有商品全部显示已完成的时候，提示该任务已经完成，是否删除任务。